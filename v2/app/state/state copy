/**
 * @module state.ts
*/
import { addHours, addMinutes, eachDayOfInterval, isBefore, isPast, isSameDay } from 'date-fns';
import { deAT } from 'date-fns/locale';
import 'regenerator-runtime/runtime';
import { decodedTextSpanIntersectsWith } from 'typescript';
import { PeriodsRequest } from '../CORS/entities/apiExchange/clientTypes';
import { CarListResponse, FreePeriodResponse, PlacesResponse, SingleCar, SinglePeriod } from "../CORS/entities/apiExchange/serverTypes"
import { getCarList, getPlaceList, getCarPeriodList } from "../CORS/querySender";
import { Car } from '../entities/Car';
import { SingleCarWithPeriods } from '../entities/carPeriods';
import { formatCarModel } from '../shared/sharedActions';
import eachMinuteOfInterval from 'date-fns/eachMinuteOfInterval';
import _ from 'lodash'


function numberOfEl(el: Date, arr: Date[]): number {
	const n: number = arr.filter((d) => d === el).length;
	return n;

}
export class State {

	private places: PlacesResponse = { result_code: 0, places: [] };
	private cars: CarListResponse = { result_code: 0, cars: [] };
	private selectedCar: SingleCar[] = [];
	private selectedPeriods: FreePeriodResponse[] = []
	private customersPhone: string | undefined = '';
	private customersName: string | undefined = '';
	private carPeriods: SingleCarWithPeriods[] = [];//free periods
	private busyCarPeriods: SingleCarWithPeriods[] = [];
	private fullbusyDates: Date[] = [];
	private busyTimestamps: Date[] = [];

	/**
	 * @description сервер принимет дату в виде "2021-11-01 10:00Z", поэтому timestamp требуется постоянно переводить в этот формат, для чего служит эта функция
	*/
	private reformatDate(dt: Date): string {
		return `${dt.toLocaleDateString().split('.').reverse().join('-')} ${dt.toLocaleTimeString()}Z`;
	}

	private splitPeriodBorder(start: Date, direction: string): Date[] {
		const hours: number = start.getHours();
		const mins: number = start.getMinutes();
		if (hours === 0 && mins === 0) {

			return []; //если время 00:00 то это не пограничный элемент
		}

		if (direction === 'forward') {
			let nextDay: Date = new Date(start.getFullYear(), start.getMonth(), start.getDate() + 1, 0, 0, 0);
			return eachMinuteOfInterval({ start: start, end: nextDay }, { step: 15 });
		}
		else if (direction === 'backward') {
			let startOfDay: Date = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 0, 0, 0);
			return eachMinuteOfInterval({ start: startOfDay, end: start }, { step: 15 });
		}

		throw new Error("State::splitPeriodBorder: unexpected dirrection!");
	}

	private splitPeriodBody(start: Date, end: Date): Date[] {
		const roundStart = new Date(start.getFullYear(), start.getMonth(), start.getDate() + 1, 0, 0); //мы берем следующий день как начало тела периода, потому что дробные части мы учли в startborder
		const roundEnd = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 0, 0); //мы берем начало дня как конец тела периода, потому что дробные части мы учли в endBorder
		// console.log({ roundStart, roundEnd });

		return eachDayOfInterval(
			{ start: roundStart, end: roundEnd }, { step: 1 }
		)
	}

	private fillBusy(): void {
		this.busyCarPeriods.forEach(
			(carAndPeriod: SingleCarWithPeriods) => {
				carAndPeriod.car_periods.forEach(
					(period: SinglePeriod) => {

						const startBorder: Date[] = this.splitPeriodBorder(new Date(period.begin), 'forward');
						const endBorder: Date[] = this.splitPeriodBorder(new Date(period.end), 'backward');
						this.busyTimestamps = [...this.busyTimestamps, ...startBorder, ...endBorder];

						const periodBody: Date[] = this.splitPeriodBody(new Date(period.begin), new Date(period.end));
						this.fullbusyDates = [...this.fullbusyDates, ...periodBody];
					}
				)
			}
		);
		const group = Object.values(_.groupBy(this.busyTimestamps)).filter((it) => it.length === this.selectedCar.length);
		this.busyTimestamps.splice(0, this.busyTimestamps.length);
		group.forEach(
			(it) => {
				this.busyTimestamps = [...this.busyTimestamps, ...it]
			}
		);
		this.busyTimestamps = _.uniq(this.busyTimestamps);

		const dtGroup = Object.values(_.groupBy(this.fullbusyDates)).filter((it) => it.length === this.selectedCar.length);
		this.fullbusyDates.splice(0, this.fullbusyDates.length);
		dtGroup.forEach(
			(it) => {
				this.fullbusyDates = [...this.fullbusyDates, ...it]
			}
		);
		this.fullbusyDates = _.uniq(this.fullbusyDates);
		

	}

	private async fetchPeriods(): Promise<void> {
		const promises: Promise<FreePeriodResponse>[] = []
		this.selectedCar.forEach(
			async (car) => {
				let begDate = new Date(new Date().getFullYear(), 0, 1);
				let endDate = new Date(new Date().getFullYear() + 1, 0, 1);
				const req: PeriodsRequest = {
					car_id: car.car_id,
					begin: this.reformatDate(begDate),
					end: this.reformatDate(endDate),
					include_idles: true,
					include_reserves: true,
				}

				const periods: Promise<FreePeriodResponse> = getCarPeriodList(req);
				promises.push(periods);


			}
		);
		const res: FreePeriodResponse[] = await Promise.all(promises);
		
		res.forEach(
			(period, inx) => {
				const splitPeriods: Date[] = [];
				period.car_periods.forEach(
					(period): void => {
						//убираем завершающий символ Z, чтобы избежать несвоевременного перевода в UTC
						period.begin = period.begin.toString().slice(0, period.begin.toString().length - 1);
						period.end = period.end.toString().slice(0, period.end.toString().length - 1);
						splitPeriods.push(new Date(period.begin));
						splitPeriods.push(new Date(period.end));

					}
				);

				//убираем первый begin и последний end, для того, чтобы получить периоды занятости авто, а не свободы

				splitPeriods.splice(0, 1);
				splitPeriods.splice(splitPeriods.length - 1, 1);

				const busyPeriods: SinglePeriod[] = new Array(splitPeriods.length / 2);
				for (let i = 0; i < splitPeriods.length; i += 2) {

					busyPeriods.push({
						begin: splitPeriods[i],
						end: splitPeriods[i + 1],
					});
				}



				this.busyCarPeriods.push(
					{ ...this.selectedCar[inx], car_periods: busyPeriods }
				);
			}
		);


	}
	constructor() { }

	public async init(): Promise<State> {
		const places: PlacesResponse = await getPlaceList();
		places.places.splice(0, 3);//смысл убрать первые 3 элемента в том, что об этот попросил заказчик
		this.places = places;

		this.cars = await getCarList();
		console.log(this.cars);
		
		const carName = location.hash.replace('#','');
		await this.selectCar(carName);
		return this;
	}


	public getPlaces(): PlacesResponse {
		const places = this.places;
		return { result_code: places.result_code, places: places.places };
	}

	public savePhone(num: string | undefined): void {
		this.customersPhone = num;
	}

	public getPhone(): String | undefined {
		return new String(this.customersPhone).toString();
	}

	public saveName(name: string | undefined): void {
		this.customersName = name;

	}

	public getName(): String | undefined {
		return new String(this.customersName).toString();

	}

	public getCars(): CarListResponse {
		const res = this.cars;
		return { result_code: res.result_code, cars: res.cars };

	}

	public async selectCar(carStr: string | undefined): Promise<void> {
			
		const res = this.cars.cars.filter(
			(car) => {
				return formatCarModel(car.model).trim().replace(/\s/g, '_').toLowerCase() === carStr
			}
		)
		
		this.busyCarPeriods.splice(0, this.busyCarPeriods.length);
		this.fullbusyDates.splice(0, this.fullbusyDates.length);
		this.busyTimestamps.splice(0, this.busyTimestamps.length);
		this.selectedCar = res;
		await this.fetchPeriods();
		this.fillBusy();
		

	}

	public getSelectedCars(): SingleCar[] {
		return this.selectedCar.map(
			(item: SingleCar) => {
				return { car_id: item.car_id, model: item.model, year: item.year };
			}
		);
	}

	public isDateBusy(dt: Date): Boolean {
		// if ( isPast(dt) ) return true;
			
		if (this.fullbusyDates.find(
			(d) => isSameDay(new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 0, 0), d))) {
				
			return true;
		}
		return false;

	}

}
export const BookingState = () => (new State()).init();